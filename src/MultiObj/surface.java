package MultiObj;

import java.util.ArrayList;

import IMRT_DAO.TreatmentPlan;

public class surface {
	ArrayList<TreatmentPlan> initialListSolutions;/* This list contain the extreme solution and the middle point*/
	ArrayList<TreatmentPlan> extremeSolution;/*This list only contain the extreme points  the first point have de less x value*/
	ArrayList<TreatmentPlan> allSolution;/*This list contain all the solution generated by the surface */
	equation shapeEquation;/* In this variable is save the quadratic function shape generated by the initialListSolution points */
	ArrayList<equation>shape=new ArrayList<equation>();
	ArrayList<Integer>BACs;
	
	public surface(TreatmentPlan a) {
		
	}
	
	public surface(TreatmentPlan a,TreatmentPlan b) {
		extremeSolution=new ArrayList<TreatmentPlan> ();
		initialListSolutions=new ArrayList<TreatmentPlan> ();
		allSolution=new ArrayList<TreatmentPlan> ();
		extremeSolution.add(a);
		extremeSolution.add(b);
		initialListSolutions.addAll(extremeSolution);
		
		TreatmentPlan c=generatePointWithExtreme(0.5);
		initialListSolutions.add(c);
		allSolution.addAll(initialListSolutions);
		equation shapeEquation1= new equation(a, c);
		equation shapeEquation2= new equation(c, b);
		shape.add(shapeEquation1);
		shape.add(shapeEquation2);
		
		}
	public surface(TreatmentPlan a,TreatmentPlan b,TreatmentPlan c) {
		extremeSolution=new ArrayList<TreatmentPlan> ();
		initialListSolutions=new ArrayList<TreatmentPlan> ();
		allSolution=new ArrayList<TreatmentPlan> ();
		extremeSolution.add(a);
		extremeSolution.add(b);
		initialListSolutions.addAll(extremeSolution);
		initialListSolutions.add(c);
		allSolution.addAll(initialListSolutions);
		equation shapeEquation1= new equation(a, c);
		equation shapeEquation2= new equation(c, b);
		shape.add(shapeEquation1);
		shape.add(shapeEquation2);
		
	}
	
	public double[] getExtreamPointTreatment(int index) {
		return new double[] {extremeSolution.get(index).scores[1],extremeSolution.get(index).scores[2]};
	}
	
	/**
	 * This function return the intersection between this surface and the surface b. Else return null
	 * @param b
	 * @return
	 */
	public double[] surfaceIntersection(surface b) {
		double[] intersectionPoints=null;
		
		
		return intersectionPoints;
	}
	
	public void changeUpExtreme(TreatmentPlan newUp) {
		extremeSolution.set(0, newUp);
	}
	public void changeDownExtreme(TreatmentPlan newDown) {
		extremeSolution.set(1, newDown);
	}
		
	
	
	/* Function to do the linear combination between two treatment plan */
	public void generatePoint(int indexPointOne,int indexPointTwo) {
		allSolution.add( DAOCrossingMiddleGeneration(allSolution.get(indexPointOne),allSolution.get(indexPointTwo)));
	}
	public void generatePoint(int indexPointOne,int indexPointTwo,double percent) {
		allSolution.add( DAOCrossingMiddleGeneration(allSolution.get(indexPointOne),allSolution.get(indexPointTwo)));
	}
	
	public TreatmentPlan generatePointWithExtreme(double percent) {
		return DAOCrossingGeneration(extremeSolution.get(0),extremeSolution.get(1),percent);
	}
	private TreatmentPlan DAOCrossingMiddleGeneration(TreatmentPlan one,TreatmentPlan two) {
	return DAOCrossingGeneration(one,two, (double) 0.5);
	
	}
	private TreatmentPlan DAOCrossingGeneration(TreatmentPlan one,TreatmentPlan two, double percent) {
		TreatmentPlan crossDAO=new TreatmentPlan(one);
		crossDAO.evaluationFunction=3;
		crossDAO.setIntensity(intensitiesLinearCombination(one.getIntensityApertures(), two.getIntensityApertures(), percent));
		crossDAO.evaluateSolution();
		return crossDAO;
		
	}
	
	
	/**
	 * This function made a linear combination of the two intensities
	 * Consider that the function only work with itnensities that have the same number of bac and same number  of apertures for all bacs
	 * @param a
	 * @param b
	 * @param alfa
	 * @return
	 */
	private double [][] intensitiesLinearCombination(double [][] a,double [][] b,double alfa){
		double [][]linearCombination=new double [a.length][a[0].length];
		for(int i=0;i<a.length;i++) {
			for(int j=0;j<a[i].length;j++) {
				linearCombination[i][j]=(alfa*a[i][j])+((1-alfa)*b[i][j]);
			}
		}
		return linearCombination;
	}
	
	/**
	 * This function return True if point x1,y2 dominate x2,y2
	 * we consider use the week dominance to this function
	 * @param x1
	 * @param y1
	 * @param x2
	 * @param y2
	 * @return
	 */
	public boolean dominate(double x1, double y1, double x2, double y2) {
	        return ((x1 < x2) && (y1 <= y2))&&((x1 <= x2) && (y1 < y2));
	}

	public int surfaceDominate(surface surfaceToCompare) {
		int flag=0;
		for(TreatmentPlan point:initialListSolutions) {
			int dominatedPoint=0;
			for(TreatmentPlan pointCompared:surfaceToCompare.initialListSolutions) {
				if(dominate(point.scores[0],point.scores[1],pointCompared.scores[0],pointCompared.scores[1])) {
					
				}else {
					dominatedPoint=1;
					break;
				}
			}
		}	
		return flag;		
	}
	
	public void printInitialList() {
		for(TreatmentPlan treat:initialListSolutions) {
			treat.print();
		}
	}
	
	public void printAllList() {
		for(TreatmentPlan treat:allSolution) {
			treat.print();
		}
	}
	

	
	
	
	
}
